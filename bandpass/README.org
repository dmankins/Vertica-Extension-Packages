* Python Bandpass filters

This repository contains Python user-defined functions (UDFs) for
highpass and low-pass filters on time-series data.

The algorithms implemented are drawn from the descriptions of the
discrete-time versions described in Wikipedia: 

 - https://en.wikipedia.org/wiki/Low-pass_filter
 - https://en.wikipedia.org/wiki/High-pass_filter

* Installation

** Execute the following scripts from the source directory

The following scripts use *pwd* to set the absolute pathname of
*lowpass_data.csv*, *highpass_data.csv*,the *lowpass.py* library, and
the *highpass.py* library.  Please execute them in the directory where
those files are located.

*** Loading the data into Vertica from the CSV file

(Note: the following SQL scripts presume that your Vertica has
flextables installed.)

For historical reasons we have two data-sets intended for the
different filters --- *highpass.csv* and *lowpass.csv*.  The
algorithms can be run on either dataset, of course.

#+BEGIN_SRC bash
vsql -f lowpass_load.sql
vsql -f highpass_load.sql
#+END_SRC

*lowpass_load.sql* will load the data from *lowpass_data.csv* into a flextable,
*lowpass_data*.  It then derives a standard Vertica table,
*lowpass_data_with_deltas*, which has columns:
 - row_n :: The row number of the data
 - tstamp :: The timestamp from the data (*row_n* and *tstamp* may be
             redundant, as they have the same ordering).
 - dt :: the "delta" of this row's timestamp from the previous row's
         timestamp.  Used as the "delta-t" in the discrete low- and
         highpass filter algorithms.
 - reading :: the sensor reading for this time
 - dreading :: the "delta" of this reading from the previous row's
               reading.  Used as the "delta-signal" in the discrete
               low- and highpass filter algorithms.
 
*highpass_load.sql* does the same thing for the highpass data in
*highpass.csv*, creating:
*lowpass_data*.  It then derives a standard Vertica table,
*highpass_data_with_deltas*, which has similar columns to
**lowpass_data_with_deltas*: 
 - row_n :: The row number of the data
 - tstamp :: The timestamp from the data (*row_n* and *tstamp* may be
             redundant, as they have the same ordering).
 - dt :: the "delta" of this row's timestamp from the previous row's
         timestamp.  Used as the "delta-t" in the discrete low- and
         highpass filter algorithms.
 - reading :: the sensor reading for this time
 - dreading :: the "delta" of this reading from the previous row's
               reading.  Used as the "delta-signal" in the discrete
               low- and highpass filter algorithms.

** Loading the libraries

The libraries are loaded by the first few lines of *lowpass_load.sql*
and *highpass_load.sql*.  These two SQL scripts must be run in the
directory containing *p_lowpass.py* and *highpass.py*.

*** Loading the lowpass library

We inform Vertica about the file to load the library from by giving it
an absolute pathname to the library, then informing Vertica how to
find the function-factory within the library.

Run these commands in the directory containing *p_lowpass.py*:

#+BEGIN_SRC sql
\set library lowpasslib
\set libfile ''''`pwd`'/p_lowpass.py'''

DROP LIBRARY IF EXISTS :library CASCADE;
CREATE LIBRARY :library AS :libfile LANGUAGE 'Python';
CREATE FUNCTION lowpass 
    AS LANGUAGE 'Python' NAME 'p_lowpass_factory' 
    LIBRARY :library fenced;
#+END_SRC

*** Loading the highpass library

The commands for loading the highpass library are similar to those
used to load the lowpass library.  

Run these commands in the directory containing *lowpass.py*:

#+BEGIN_SRC sql
\set library highpasslib
\set libfile ''''`pwd`'/highpass.py'''

drop library :library cascade;
CREATE LIBRARY :library AS :libfile LANGUAGE 'Python';
CREATE FUNCTION highpass AS LANGUAGE 'Python' NAME 'highpass_factory' LIBRARY :library fenced;
#+END_SRC

** Running the functions

There are two files, *highpass_run.sql* and *lowpass_run.sql* which
can be used to run the libraries.

*** p_lowpass

*lowpass_run.sql* runs the lowpass algorithm across several sets of
parameters for frequency and for "alpha".  The alpha parameter is
meaningful in the context of the viewing the lowpass filter as an RC
circuit (alpha = RC/(RC + delta_t)).

The interface for the lowpass function is:
#+BEGIN_SRC sql
p_lowpass(
    <float-delta-time>, 
    <float-sensor-reading> 
    USING PARAMETERS "frequency" = <float-frequency-in-hz>
) ORDER BY timestamp;
--- or
p_lowpass(
    <float-delta-time>, 
    <float-sensor-reading> 
    USING PARAMETERS "alpha" = <float-alpha>
) ORDER BY timestamp;
#+END_SRC
It returns a float value for each row representing the output of the
lowpass filter at that point.

Where:
 - <float-delta-time> :: the time-interval between this sensor
      reading and the previous one in seconds (e.g., 0.01)
 - <float-sensor-reading> :: the sensor reading in whatever units
      you're measuring
 - <float-frequency-in-hz> :: the cutoff frequency for the filter in
      hertz 
 - <float-alpha> :: 0 < alpha < 1

*alpha* can be defined in terms of frequency, *f* and *delta_T*:

alpha = delta_T / (RC + delta_T)

alpha = 2*pi*delta_T*f/((2*pi*delta_T*f) + 1)

Similarly, *f* can ge defined in terms of *alpha* and *delta_T*:

f = alpha/((1-alpha)*2*pi*delta_T)

*** highpass

*highpass_run.sql* runs the highpass algorithm on the
*highpass_data_with_deltas* table created by *highpass_load.sql*,
*using different cutoff frequencies.

The interface for the highpass function is:

#+BEGIN_SRC sql
highpass(<float-frequency>, <float-delta-time>, <float-sensor-reading>) 
ORDER BY timestamp;
#+END_SRC

Where:
 - <float-frequency> :: the cutoff frequency in hertz
 - <float-delta-time> :: the time-interval between this sensor reading
      and the previous one, in seconds, e.g., 0.01.
 - <float-sensor-reading> :: the sensor reading in whatever units
      you're measuring.

** Plotting the result

*plot_parallel.py* uses the *vertica_python* python module to read the data from
Vertica.  

It takes as arguments a list of column names and a table name, e.g., 

#+BEGIN_SRC bash
python3 plot_parallel.py reading f001 f0016 f002 f01 f1 f5 lowpass_out
#+END_SRC

The "fnnn" column names are derived from 0.001, 0.0016, 0.002, 0.01,
.1 and .5 hertz.  On these plots, a 1 hertz signal would be 100 ticks
wide on the *x*-axis. 

Will create (separate) plots of the *reading*, *f001*, *f0016*,
*f002*, *f01*, *f1*, and  *f5* columns of the *lowpass_out* table
created by *lowpass_run.sql*.

It puts its output into a PNG file with a name constructed from the
table and column names, as well as running an interactive display
which can be manipulated.  Note that the vertical scales may differ.

Here is an example of the output:

[[./lowpass_out_reading_f001_f0016_f002_f01_f1_f5_cols.png]]

(X-axis measures "ticks" in the data-set --- ticks are uniformly
happening at 0.01 second in the lowpass dataset.)

Stacking the plots as *plot_parallel.py* does is useful when comparing
things with radically different ranges in the vertical axis.  For
things like the lowpass output, which cover the same range in the
vertical axis, you can also use *plot_overlay.py* to look at three
columns on one plot:

#+BEGIN_SRC bash
python3 plot_overlay.py reading f001 f002 f01 lowpass_out
#+END_SRC

The results are seen here:

[[./lowpass_out_overlay_reading_f001_f002_f01_cols.png]]

This plot shows a problem with this implementation of a low-pass
filter: namely, as the critical frequency decreases the system has
more "inertia" responding to changes in the signal more slowly.  The
curve gets smoother, but part of that smoothness comes at a cost in
delay.

* High pass filter

** Running the highpass filter on the low-pass data

The first argument in the *highpass* UDF is frequency in hertz.  In
this data-set, a one-hertz signal takes 100 units on the *x* axis.

#+BEGIN_SRC sql
DROP TABLE IF EXISTS highpass_on_lpd_out CASCADE;
CREATE TABLE highpass_on_lpd_out AS
SELECT lowpass_data_with_deltas.row_n,
       reading,
       highpass(1, dt, reading) as f1,
       highpass(5, dt, reading) as f5,
       highpass(10, dt, reading) as f10,
       highpass(100, dt, reading) as f100
FROM lowpass_data_with_deltas ORDER BY row_n; 
#+END_SRC

With the results shown here:

[[./highpass_on_lpd_out_overlay_reading_f1_f5_f10_f100_cols.png]]

Surprise!  The highpass signal is down around 0!  It doesn't follow
the offset of the signal.  Why?  The offset is *low-frequency data*
that gets filtered out.

If we set aside the raw input, we can see more detail in the highpass
output: 

[[./highpass_on_lpd_out_overlay_f1_f5_f10_f100_cols.png]]

** Running the highpass filter on the highpass data

The script *highpass_run.sql* runs the highpass filter on the highpass
dataset loaded by *highpass_load.sql*.

Plotted with 

#+BEGIN_SRC bash
python3 plot_overlay.py reading f5 f100 f10000 highpass_out
#+END_SRC

(which ignores some of the columns) produces the following results:

[[./highpass_out_overlay_reading_f5_f100_f10000_cols.png]]

* Comparison of these filters to filtering with Fourier Transforms

Partly because of annoyance at the squiggles that remain in the
lowpass filter output, I decided to compare these functions to
filtering with Fourier transforms.  Basically, take Fourier Transform
of the signal, lop off the frequencies you're not interested in, then
take the inverse-Fourier Transform to see the filtered signal.

The file *fft.py* uses the *numpy.fft* module to take the Fast Fourier
Transform (FFT) of the entire dataset, then plots the result in
comparison to some of the results of the lowpass and highpass discrete
filters.

The following plot shows a comparison between filtering-via FFT and
filtering via discrete filters:

[[./comparison_fft_to_discrete_filters.png]]

The FFT software used reads the entire contents of the array into
memory, so it is limited in the size of the table it processes.


