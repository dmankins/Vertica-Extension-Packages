"""
A quick script to read the results from
 - lowpass_out
 - highpass_out
To get the results of the discrete lowpass and highpass filters.

Do an FFT on the "raw data", takes two copies of the resulting
spectrum, discards the high frequencies from one spectrum, and the low
frequencies from the other spectrum.

Do inverse FFTs on the transformed spectra, and you've got another way
to do lowpass and highpass filters.

Plot the results to compare the behavior of the discrete filters to
the FFT filter approximations.
"""

import numpy as np
import numpy.fft as fft
import matplotlib
import matplotlib.pyplot as plt
import vertica_python

# don't have a display on (this) Unix box
# so will output to fr.png
matplotlib.use('TkAgg')

conn_info = {'host': '127.0.0.1',
             'port': 5433,
             'user': 'dmankins',
             # 'password': 'some_password',
             # 'database': 'a_database',
             # autogenerated session label by default,
             # 'session_label': 'some_label',
             # default throw error on invalid UTF-8 results
             'unicode_error': 'strict',
             # SSL is disabled by default
             'ssl': False,
             # autocommit is off by default
             'autocommit': True,
             # using server-side prepared statements is disabled by default
             'use_prepared_statements': True,
             # connection timeout is not enabled by default
             # 5 seconds timeout for a socket operation (Establishing a TCP connection or read/write operation)
             # 'connection_timeout': 60
             }

table = 'lowpass_out'
cols = 'reading'
cols_for_sql = cols

rows = []
discrete_rows = []
rowcnt = 0
with vertica_python.connect(**conn_info) as conn:
    cur = conn.cursor()
    # put row_n last so we can use enumerate(cols) later
    cur.execute(f'SELECT {cols_for_sql}, row_n FROM {table} ORDER BY row_n');
    # Why two loops over more-or-less the same table?  Cut-and-paste
    # hold-over from other code.  Could add the reading column to the
    # other SELECT and just do one.  But for now, it works, is
    # still reasonably fast on my data-set, and it's just a quick
    # sanity check, so I'm not going to bother fixing it.
    for row in cur.iterate():
        rows.append([float(x) for x in row])
    cur = conn.cursor()
    cur.execute(f'SELECT lp.f001 AS l_f001, hp.f1 AS h_f1, lp.row_n as row_n FROM lowpass_out AS lp, highpass_on_lpd_out AS hp where lp.row_n = hp.row_n ORDER BY lp.row_n')
    for row in cur.iterate():
        discrete_rows.append([float(x) for x in row])

# toss out the first and last rows because edge effects of the filters
rows = rows[3:-1]
rowarray = np.array(rows)

discrete_rows = discrete_rows[3:-1]
discrete_rowarray = np.array(discrete_rows)

# using real fft
spectrum = fft.rfft(rowarray[:,0])

# make copies of the spectrum so we can modify the copies
low = spectrum.copy()
# save a little space by re-using the original spectrum
# but "high" is a clearer name for it in what follows
high = spectrum

# In the following "10" is just a number I tried and got decent
# results with, there's no more to the choice of what to discard than
# that.

# low-pass: discard all but the low freqs
low[10:] = 0
low_ifft = fft.irfft(low)

# high-pass: discard the low freqs
high[0:10] = 0
high_ifft = fft.irfft(high)

# plot the FFT-derived highpass and lowpass
plt.plot(high_ifft, color='blue', label='FFT high-pass', alpha=0.3)
plt.plot(low_ifft, color='red', label='FFT low-pass', alpha=0.3)

# plot the raw data
plt.plot(rowarray[:,0], color='gray', label='signal', alpha=0.3)

# plot the results of the discrete filters
# deliberately switch red and blue around so can distinguish
# the fft-version from the discrete-filter version even when they
# overlap  
plt.plot(discrete_rowarray[:,2],
         discrete_rowarray[:,0],
         color='blue',
         linestyle=':',
         label='discrete low-pass',
         alpha=0.3)
plt.plot(discrete_rowarray[:,2],
         discrete_rowarray[:,1],
         color='red',
         linestyle=':',
         label='discrete high-pass',
         alpha=0.3)
plt.legend()

png_name = f'comparison_fft_to_discrete_filters.png'
print(f'Output to {png_name}')
plt.savefig(png_name)
plt.show()
