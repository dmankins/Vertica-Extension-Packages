import numpy as np
import numpy.fft as fft
import matplotlib
import matplotlib.pyplot as plt
import vertica_python

# don't have a display on (this) Unix box
# so will output to fr.png
matplotlib.use('TkAgg')

conn_info = {'host': '127.0.0.1',
             'port': 5433,
             'user': 'dmankins',
             # 'password': 'some_password',
             # 'database': 'a_database',
             # autogenerated session label by default,
             # 'session_label': 'some_label',
             # default throw error on invalid UTF-8 results
             'unicode_error': 'strict',
             # SSL is disabled by default
             'ssl': False,
             # autocommit is off by default
             'autocommit': True,
             # using server-side prepared statements is disabled by default
             'use_prepared_statements': True,
             # connection timeout is not enabled by default
             # 5 seconds timeout for a socket operation (Establishing a TCP connection or read/write operation)
             # 'connection_timeout': 60
             }

table = 'lowpass_out'
cols = 'reading'
cols_for_sql = cols

rows = []
discrete_rows = []
rowcnt = 0
with vertica_python.connect(**conn_info) as conn:
    cur = conn.cursor()
    # put row_n last so we can use enumerate(cols) later
    cur.execute(f'SELECT {cols_for_sql}, row_n FROM {table} ORDER BY row_n');
    for row in cur.iterate():
        rows.append([float(x) for x in row])
    cur = conn.cursor()
    cur.execute(f'SELECT lp.f001 AS l_f001, hp.f1 AS h_f1, lp.row_n as row_n FROM lowpass_out AS lp, highpass_on_lpd_out AS hp where lp.row_n = hp.row_n ORDER BY lp.row_n')
    for row in cur.iterate():
        discrete_rows.append([float(x) for x in row])

# toss out the first and last rows because edge effects of the filters
rows = rows[3:-1]
rowarray = np.array(rows)

discrete_rows = discrete_rows[3:-1]
discrete_rowarray = np.array(discrete_rows)

# using real fft
spectrum = fft.rfft(rowarray[:,0])

# make copies of the spectrum so we can modify the copies
low = spectrum.copy()
# save a little space by re-using the original spectrum
# but "high" is a clearer name for it in what follows
high = spectrum

# low-pass: discard all but the low freqs
low[10:] = 0
low_ifft = fft.irfft(low)

# high-pass: discard the low freqs
high[0:10] = 0
high_ifft = fft.irfft(high)

# plot
plt.plot(high_ifft, color='blue', label='FFT high-pass', alpha=0.3)
plt.plot(low_ifft, color='red', label='FFT low-pass', alpha=0.3)
plt.plot(rowarray[:,0], color='gray', label='signal', alpha=0.3)
# deliberately switch red and blue around so can distinguish
# the fft-version from the discrete-filter version even when they
# overlap  
plt.plot(discrete_rowarray[:,2],
         discrete_rowarray[:,0],
         color='blue',
         linestyle=':',
         label='discrete low-pass',
         alpha=0.3)
plt.plot(discrete_rowarray[:,2],
         discrete_rowarray[:,1],
         color='red',
         linestyle=':',
         label='discrete high-pass',
         alpha=0.3)
plt.legend()

png_name = f'comparison_fft_to_discrete_filters.png'
print(f'Output to {png_name}')
plt.savefig(png_name)
plt.show()
